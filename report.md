1. 자기소개
안녕하세요, 8년 차 프론트엔드 개발자이자 개발팀 팀장을 맡고 있는 도현우입니다.
저는 개발 그 자체뿐만 아니라 팀원들과의 협업 역시 매우 중요하게 생각하며, 항상 이를 염두에 두고 업무를 수행해 왔습니다.

그동안 다양한 환경에서 초기 환경 세팅부터 개발, 유지보수까지 경험을 쌓아왔습니다.
프론트엔드 개발자로서 화면단의 기능 구현이 중요하다고 생각하지만, 특히 보안 및 인증 솔루션에 많은 관심을 가지고 있습니다.
오스랩스가 제공하는 인증 서비스에 큰 흥미를 느껴 지원하게 되었습니다.
회사에서 제공하는 솔루션을 배우고 같이 개발하여 더욱 안전하고 신뢰성 있는 서비스를 제공하는 데 기여하고 싶습니다.

마지막으로 회사와 함께 성장하는 개발자가 되고자 합니다.
감사합니다.

2. next나 nuxt 써봤는지 써봤다면 차이점 설명
Nuxt.js와 Next.js는 각각 Vue.js와 React.js 기반의 애플리케이션 개발을 위해 최적화된 프레임워크입니다.
두 프레임워크 모두 SSR과 SSG를 지원하며, SEO 최적화와 성능 향상에 도움을 줍니다.
Vue.js 생태계에 익숙하다면 Nuxt.js를, React.js 생태계에 익숙하다면 Next.js를 선택하는 것이 좋습니다.
두 프레임워크 모두 뛰어난 개발 경험과 다양한 기능을 제공하여 프로젝트의 요구 사항에 맞게 선택할 수 있습니다.
차이점은 라우트에서 미들웨어를 제공하는지 안 하는지에 유무 차이입니다.

3. typescript 사용 유무
현업에서 직접적으로 사용해보지는 않았습니다.
interface를 통하거나 파라미터에 타입을 지정해주는 작업은 진행해보았지만
class 문법을 통해서 constructor에서 타입을 지정해주거나 유니언이나 교차 타입 혹은 믹스인 등을
사용하는 고금 더 고차원 작업은 못 해봤습니다.

4. 이직이 잦은 이유
우선, 제가 다녔던 두 곳은 임금 체불 문제가 있었습니다. 이러한 상황에서는 제 경력과 생활을 위해 어쩔 수 없이 이직을 선택할 수밖에 없었습니다
또한, 한 곳은 대표님의 법적인 문제로 인해 회사가 정상적으로 운영되지 못해 이직을 하게 되었습니다.

하지만 이 과정을 통해 저는 여러 가지 귀중한 경험을 얻을 수 있었습니다.
각 회사에서 다양한 프로젝트와 기술을 접하며 제 개발 역량을 넓힐 수 있었고, 어려운 상황에서도 문제를 해결하고 팀원들과 협력하는 법을 배웠습니다.
또한, 각기 다른 환경에 빠르게 적응하고, 다양한 문제를 해결해 나가는 과정에서 제 자신을 더욱 성장시킬 수 있었습니다.

5. Vue 인스턴스란 무엇인가요?
Vue 인스턴스는 Vue 애플리케이션의 기본 단위로, Vue 애플리케이션을 만드는 데 필요한 모든 속성과 메서드를 포함하는 객체입니다. Vue 인스턴스는 주로 new Vue()를 통해 생성되며, 데이터, 템플릿, 마운트할 DOM 요소, 메서드, 라이프사이클 훅 등 다양한 옵션을 설정할 수 있습니다.

6. 템플릿 문법을 설명해 주세요.
Vue의 템플릿 문법은 HTML 기반으로, 데이터를 바인딩하고 DOM을 동적으로 렌더링할 수 있습니다. 주요 문법 요소는 다음과 같습니다:

Mustache Syntax: {{ message }}
디렉티브: v-bind, v-model, v-for, v-if, v-else, v-show, v-on 등
컴포넌트 사용: <my-component></my-component>

7. 데이터 바인딩이란 무엇인가요?
데이터 바인딩은 Vue의 중요한 기능으로, 데이터를 DOM에 동기화하는 방법입니다. Vue에서는 단방향 바인딩과 양방향 바인딩을 모두 지원합니다:

단방향 바인딩: v-bind 또는 :를 사용하여 데이터를 HTML 속성에 바인딩합니다.
양방향 바인딩: v-model을 사용하여 폼 입력 요소와 데이터를 양방향으로 바인딩합니다.

8. Vue의 반응형 시스템이 어떻게 작동하는지 설명해 주세요.
Vue의 반응형 시스템은 데이터가 변경될 때 DOM을 자동으로 업데이트합니다. Vue는 객체 속성을 getter와 setter로 감싸서 변화를 감지합니다. 데이터가 변경되면 Vue는 이를 추적하고, 관련된 DOM을 효율적으로 업데이트합니다.

9. props와 state의 차이점은 무엇인가요?
props: 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달하는 방법입니다. props는 읽기 전용이며, 자식 컴포넌트 내에서 수정할 수 없습니다.
state: 컴포넌트의 로컬 상태로, 컴포넌트 내에서 선언되고 관리됩니다. 컴포넌트 내부에서 데이터를 변경할 수 있습니다.
컴포넌트 간의 데이터 전달 방법을 설명해 주세요.
Props: 부모에서 자식으로 데이터를 전달합니다.
Event Emitting: 자식에서 부모로 이벤트를 발생시켜 데이터를 전달합니다.
Vuex: 글로벌 상태 관리를 통해 컴포넌트 간 데이터를 공유합니다.
Provide/Inject: 상위 컴포넌트에서 하위 컴포넌트로 데이터를 전달합니다.

10. 컴포넌트 생명주기를 설명해 주세요.
Vue 컴포넌트는 특정 시점에 호출되는 일련의 라이프사이클 훅을 가지고 있습니다:

beforeCreate: 컴포넌트가 생성되기 전
created: 컴포넌트가 생성된 후
beforeMount: DOM에 마운트되기 전
mounted: DOM에 마운트된 후
beforeUpdate: 데이터가 변경되기 전
updated: 데이터가 변경된 후
beforeDestroy: 컴포넌트가 파괴되기 전
destroyed: 컴포넌트가 파괴된 후

11. 동적 라우트 매칭이란 무엇인가요?
동적 라우트 매칭은 URL 경로의 일부를 동적으로 처리하여 다양한 URL 패턴을 매칭할 수 있게 합니다. 예를 들어, /user/:id 경로는 /user/1, /user/2 등 다양한 사용자 ID를 처리할 수 있습니다.

12. 라우트 가드란 무엇인가요?
라우트 가드는 라우터를 통해 특정 경로로 이동할 때 실행되는 함수로, 사용자가 특정 페이지에 접근하기 전에 조건을 검사할 수 있습니다. 이를 통해 인증, 권한 검사 등을 수행할 수 있습니다. 주요 라우트 가드는 beforeEach, beforeResolve, afterEach 등이 있습니다.

13. 프론트에서 보안 처리하는 방법
세션: 서버에서 세션을 생성하고 클라이언트는 세션 ID를 쿠키에 저장합니다.
쿠키: 클라이언트 측에 데이터를 저장하고, 서버와 통신 시 쿠키를 포함합니다. HttpOnly 및 Secure 플래그를 설정해 보안을 강화합니다.
토큰: JWT 등을 사용하여 클라이언트와 서버 간에 안전하게 인증 정보를 주고받습니다.
패스워드 암호화: 해싱 알고리즘을 사용하여 비밀번호를 암호화합니다.
리캡차: 봇 공격을 방지하기 위해 구글 리캡차를 사용합니다.

14. 자바스크립트 생태계에서 상태 관리하는 라이브러리
Vuex: Vue.js 애플리케이션을 위한 상태 관리 패턴 및 라이브러리
Redux: React 애플리케이션을 위한 상태 관리 라이브러리
MobX: 상태 관리를 위해 반응형 프로그래밍을 사용하는 라이브러리
이 중 vuex를 제외하고 2개를 사용해 보았고 vuex를 쓰지 않은건 composition api를 사용해서
이 부분을 해결했기 때문입니다.

15. Mixin이란 무엇인가요?
Mixin은 여러 컴포넌트 간에 재사용할 수 있는 공통 로직을 정의하는 방법입니다. Mixin에 정의된 데이터와 메서드는 이를 사용하는 모든 컴포넌트에 병합됩니다.

16. Vue에서 ref와 reactive 차이 그리고 compute 같은 기본 메소드 추가 설명
ref: 기본 데이터 유형(숫자, 문자열, 불리언 등)과 DOM 요소를 반응형으로 만들 때 사용합니다.
reactive: 객체와 배열을 반응형으로 만들 때 사용합니다.
computed: 계산된 속성을 정의하며, 종속된 데이터가 변경될 때만 다시 계산됩니다.
watch: 특정 데이터의 변화를 감지하고 그에 따라 추가 작업을 수행합니다.

17. SSR (Server-Side Rendering)과 CSR (Client-Side Rendering)의 차이점을 설명해 주세요.
SSR: 서버에서 초기 HTML을 렌더링하여 클라이언트에 전달합니다. SEO와 초기 로딩 속도에 유리합니다.
CSR: 클라이언트에서 모든 JavaScript를 다운로드한 후 렌더링합니다. 초기 로딩이 느릴 수 있지만, 이후의 상호작용은 더 빠릅니다.

18. Vue.js 애플리케이션을 최적화하는 방법에는 어떤 것들이 있나요?
코드 스플리팅: Webpack을 사용하여 라우트 단위로 코드를 분할합니다.
지연 로딩: 필요할 때만 컴포넌트를 로딩합니다.
서버 사이드 렌더링 (SSR): 초기 로딩 속도를 개선합니다.
캐싱: Vuex 상태나 API 응답을 캐싱합니다.
성능 측정 도구: Vue DevTools와 Lighthouse 등을 사용하여 성능을 분석하고 개선합니다.

19. Vue 컴포넌트의 재사용성을 높이는 방법을 설명해 주세요.
컴포넌트화: 공통 기능을 독립적인 컴포넌트로 분리합니다.
믹스인: 재사용 가능한 로직을 믹스인으로 정의합니다.
슬롯: 컴포넌트의 유연성을 높이기 위해 슬롯을 사용합니다.
컴포지션 API: 로직을 함수로 분리하여 재사용성을 높입니다.

20. 지연 로딩(Lazy Loading)이란 무엇인가요?
지연 로딩은 필요할 때만 리소스를 로드하는 기술입니다. Vue에서는 import() 함수를 사용하여 컴포넌트를 동적으로 로드할 수 있습니다. 이를 통해 초기 로딩 속도를 개선하고, 불필요한 리소스 로드를 줄일 수 있습니다.

21. Vue에서 메모리 누수를 방지하는 방법은 무엇인가요?
이벤트 리스너 제거: 컴포넌트가 파괴될 때 등록된 이벤트 리스너를 제거합니다.
타이머 클리어: setInterval, setTimeout 등을 클리어합니다.
비동기 작업 취소: 컴포넌트가 파괴될 때 비동기 작업을 취소합니다.
Vue 인스턴스 메서드 활용: beforeDestroy와 destroyed 라이프사이클 훅에서 정리 작업을 수행합니다.

22. ref와 reactive의 차이점 요약
ref
용도: 단일 값(숫자, 문자열, 불리언, 객체 등)을 반응형으로 만들 때 사용
접근 방법: .value 속성을 통해 값에 접근하고 설정
특징: 템플릿에서 자동 언래핑(템플릿 내에서는 .value 없이 사용)
사용 사례: 컴포넌트 내부의 단일 값 상태 관리, DOM 요소 참조
reactive
용도: 객체 또는 배열을 반응형으로 만들 때 사용
접근 방법: 원본 객체처럼 속성에 직접 접근하고 설정
특징: 객체의 각 속성이 반응형으로 처리됨
사용 사례: 복합적인 상태 관리(여러 속성이나 배열을 포함하는 객체)
생명주기와 사용 시기
생명주기 관리: 둘 다 Vue 컴포넌트의 생명주기와 함께 사용할 수 있으며, onMounted, onUpdated, onUnmounted 등 라이프사이클 훅과 함께 사용
사용 시기:
ref: 단일 값 상태를 다루거나 DOM 요소를 참조할 때
reactive: 여러 속성이나 배열을 포함한 복합적인 상태를 다룰 때
이와 같이, ref는 단일 값 상태 관리에, reactive는 복합적인 상태 관리에 적합합니다. 각각의 용도와 접근 방법을 잘 이해하고 상황에 맞게 사용하는 것이 중요합니다.

23. 컴포넌트 기반 아키텍처의 장점은 무엇인가요?
재사용성: 컴포넌트를 여러 곳에서 재사용할 수 있어 코드 중복을 줄입니다.
유지보수성: 코드가 모듈화되어 있어 유지보수와 디버깅이 용이합니다.
독립성: 각 컴포넌트는 독립적으로 개발, 테스트, 배포가 가능합니다.
조직화: 코드의 구조가 명확해지고, 대규모 애플리케이션에서 관리가 용이합니다.

24. Vue.js에서 Composition API와 Options API의 차이점을 설명해 주세요.
Composition API: 함수 기반 접근 방식을 사용하여 더 유연하고 재사용 가능한 코드를 작성할 수 있습니다. 로직을 함수로 분리하여 복잡한 컴포넌트에서 가독성을 높입니다.
Options API: 객체 기반 접근 방식을 사용하여 데이터, 메서드, 계산된 속성 등을 명시적으로 정의합니다. Vue 2에서 주로 사용되던 방식으로 이해하기 쉽습니다.

25. Vue.js에서 상태 관리를 위해 Composition API를 사용하여 상태를 공유하는 방법을 설명해 주세요.
상태를 관리하는 별도의 모듈을 만들고 ref 또는 reactive를 사용해 상태를 정의합니다. 이를 import하여 여러 컴포넌트에서 공유할 수 있습니다. 예를 들어, useState라는 함수를 만들어 상태를 반환하고, 컴포넌트에서 이를 가져와 사용합니다.

26. OAuth 2.0의 주요 흐름과 이를 프론트엔드에서 구현하는 방법을 설명해 주세요. 
OAuth 2.0 흐름: 사용자가 애플리케이션에서 로그인 요청 -> 권한 서버로 리디렉션 -> 사용자 인증 -> 인가 코드 발급 -> 애플리케이션이 인가 코드를 권한 서버에 제출 -> 액세스 토큰 발급 -> 애플리케이션이 액세스 토큰을 사용해 자원 서버에 접근
프론트엔드 구현: 로그인 버튼을 통해 권한 서버로 리디렉션 -> 인증 후 인가 코드를 받아 백엔드에 전달 -> 백엔드가 액세스 토큰을 발급받아 클라이언트에 전달 -> 클라이언트가 토큰을 저장하고 API 요청 시 사용

27. JWT (JSON Web Token)를 이용한 인증 방식의 장점과 단점은 무엇인가요?
장점: 토큰 기반 인증으로 서버의 상태를 유지할 필요가 없으며, 확장성과 성능이 뛰어납니다. 클라이언트와 서버 간의 독립성을 높이고, 다양한 서비스에서 사용할 수 있습니다.
단점: 토큰이 클라이언트에 저장되므로 보안이 취약할 수 있으며, 토큰 유효기간 동안 유출 시 문제가 발생할 수 있습니다. 토큰 갱신 및 관리가 필요합니다.

28. Cross-Origin Resource Sharing (CORS)란 무엇이며, 이를 해결하는 방법은 무엇인가요?
CORS: 웹 페이지가 다른 도메인의 리소스에 접근할 수 있도록 하는 메커니즘입니다. 기본적으로 브라우저는 보안상의 이유로 크로스 도메인 요청을 제한합니다.
해결 방법: 서버에서 Access-Control-Allow-Origin 헤더를 설정하여 특정 도메인이나 모든 도메인에서의 접근을 허용합니다.

29. 프론트엔드 보안에서 XSS(교차 사이트 스크립팅)를 방지하는 방법은 무엇인가요?
입력 검증: 사용자 입력을 철저히 검증하고, 유효하지 않은 입력을 필터링합니다.
출력 인코딩: HTML, JavaScript, CSS 등의 컨텍스트에 맞게 출력을 인코딩하여 스크립트 실행을 방지합니다.
콘텐츠 보안 정책(CSP): Content-Security-Policy 헤더를 사용하여 허용된 소스에서만 스크립트를 로드하도록 설정합니다.

30. CSR(Client-Side Rendering)과 SSR(Server-Side Rendering)의 차이점과 장단점을 설명해 주세요.
CSR: 클라이언트 측에서 JavaScript로 렌더링합니다. 초기 로딩 속도가 느릴 수 있지만, 이후 페이지 전환이 빠릅니다.
장점: 유연한 사용자 경험, 빠른 페이지 전환, 클라이언트 측 라우팅
단점: 초기 로딩 속도가 느림, SEO 최적화 어려움
SSR: 서버 측에서 HTML을 렌더링하여 클라이언트에 전송합니다. 초기 로딩 속도가 빠르고, SEO에 유리합니다.
장점: 빠른 초기 로딩 속도, SEO 최적화 용이
단점: 서버 부하 증가, 복잡한 구현

31. REST API와 GraphQL의 차이점과 각각의 장단점을 설명해 주세요.
REST API: HTTP 요청을 통해 리소스를 CRUD하는 방식입니다. 각 리소스는 고유한 URL을 가집니다.
장점: 단순하고 직관적, 캐싱 용이
단점: 오버페칭과 언더페칭 문제, 고정된 엔드포인트
GraphQL: 쿼리 언어를 사용하여 클라이언트가 필요한 데이터를 정확하게 요청할 수 있습니다.
장점: 오버페칭과 언더페칭 문제 해결, 단일 엔드포인트
단점: 학습 곡선, 캐싱이 어려움

32. HTML Document 구성 및 렌더링 순서
HTML Document 구성 요소
DOCTYPE 선언: 문서 유형을 선언하여 브라우저가 페이지를 올바르게 렌더링하도록 합니다.
html 태그: 전체 HTML 문서를 감싸는 루트 요소입니다.
head 태그: 메타데이터, 스타일, 스크립트 링크 등 문서의 설정 정보를 포함합니다.
body 태그: 문서의 실제 콘텐츠를 포함합니다.
렌더링 순서
HTML 파싱 및 DOM 생성:
브라우저는 HTML 문서를 위에서 아래로 읽어가며 DOM(Document Object Model)을 생성합니다.
CSSOM 생성:
<link> 태그나 <style> 태그를 만나면 CSS 파일을 다운로드하고, CSSOM(CSS Object Model)을 생성합니다.
렌더 트리 생성:
DOM과 CSSOM을 결합하여 렌더 트리를 생성합니다. 렌더 트리는 화면에 그릴 요소들만 포함합니다.
레이아웃 (Layout):
렌더 트리의 각 요소의 크기와 위치를 계산합니다.
페인팅 (Painting):
계산된 레이아웃을 기반으로 화면에 픽셀을 그립니다.
JavaScript 실행:
<script> 태그를 만나면 JavaScript 파일을 다운로드하고 실행합니다. 이때 DOM 조작이나 이벤트 리스너 등록 등이 이루어집니다.
HTML, CSS, JavaScript의 역할
HTML: 문서의 구조와 내용을 정의합니다. 텍스트, 이미지, 링크, 폼 요소 등을 포함합니다.
CSS: 문서의 스타일을 정의합니다. 색상, 폰트, 레이아웃 등을 지정하여 HTML 요소의 시각적 표현을 제어합니다.
JavaScript: 문서의 동작을 정의합니다. 이벤트 처리, DOM 조작, AJAX 요청 등을 통해 사용자와의 상호작용을 가능하게 합니다.